# LLM-powered commit message generation

Darna validates atomic commits (ADR-000) and helps identify committable file sets (ADR-001), but generating high-quality commit messages remains a manual step. **This ADR introduces `--commit-msg` to generate conventional commit messages from staged changes using LLM agents, streamlining the "run darna → stage → craft message → commit" workflow for both autonomous agents and developers.**

The core argument: crafting clear, concise commit messages that follow conventions is time-consuming and requires understanding both the changes and the repository's commit style. LLMs excel at this task, and darna's atomic commit focus ensures the diff passed to the LLM represents a coherent, single-purpose change.

## Why LLM-generated commit messages fit darna

### Atomic commits enable better messages

Darna enforces that commits are atomic — each commit contains the files necessary to self-contained. This constraint is ideal for LLM message generation:

- **Focused context**: The staged diff represents self-contained set of files.
- **Clear intent**: Atomic commits have inherent structure (add feature X, fix bug Y) that maps naturally to conventional commit format.
- **Manageable size**: Atomic commits are small enough that the full diff fits comfortably in an LLM context window.

Contrast this with non-atomic commits, where the diff might span multiple features and/or depend on unstaged or untracked changes, making it impossible to write a meaningful single-line summary and to qualify as an atomic commit.

### Complements existing workflow

The `--committable` flag (ADR-001) already supports agent-driven commit loops. Adding message generation completes the automation:

```bash
while [ -n "$(darna --committable)" ]; do
    git add $(darna --committable)
    git commit -m "$(darna --commit-msg)"
done
```

Developers can use this for quick commits during prototyping, while autonomous agents can use it for fully automated commit workflows.

### Customizable prompt for different styles

Different projects have different commit message conventions (Conventional Commits, imperative mood, issue linking, etc.). The `--prompt-file` flag allows per-project customization while keeping a sensible default.

## Architectural decisions

| Aspect | Decision | Rationale |
|--------|----------|-----------|
| **Agent abstraction** | Interface with multiple implementations | Supports diverse tooling (Claude Code, Codex, Mistral, OpenCode) without coupling to one vendor |
| **Flag design** | Standalone `--commit-msg` flag | Orthogonal to `--committable`; works on any staged changes regardless of selection method |
| **Output** | Print message to stdout | Lets users preview/edit before committing; composable with shell |
| **Prompt** | Default + optional `--prompt-file` | Ships with good defaults; customizable per project |
| **Agent invocation** | CLI via `os/exec` | Simple, no network dependencies; agents already installed locally |
| **Diff source** | `git diff --cached` | Uses staged changes (what would be committed), not working tree |
| **Timeout** | 30 seconds default | Balances responsiveness with LLM generation time |
| **Error handling** | Fail fast with clear messages | Suggest installation if agent not found; guide user to fix issues |

## Implementation

### Agent interface

```go
package agent

type Agent interface {
    Generate(ctx context.Context, diff, prompt string) (string, error)
}

func NewAgent(agentType string) (Agent, error)
```

Implementations:

- **ClaudeAgent**: `claude code -p "$prompt"` (pipe diff to stdin)
- **CodexAgent**: `codex exec "$prompt"` (pipe diff to stdin)
- **MistralAgent**: `mistral -p "$prompt"` (pipe diff to stdin)
- **OpenCodeAgent**: `opencode run "$prompt"` (pipe diff to stdin)

All agents follow the same pattern: context-aware execution with timeout, error wrapping, and stderr capture for diagnostics.

### CLI integration

```bash
# Basic usage
darna --commit-msg=claude

# With custom prompt
darna --commit-msg=claude --prompt-file .darna-commit-prompt.txt

# In a commit workflow
git add $(darna --committable)
git commit -m "$(darna --commit-msg=claude)"

# Environment variable
export DARNA_COMMIT_MSG_AGENT=claude
darna --commit-msg  # Uses environment variable
```

### Default prompt

The built-in prompt generates Conventional Commits format messages:

```
<type>[optional scope]: <description>

Types: feat, fix, refactor, docs, test, chore, ci, perf, style, build
Scope: optional, in parentheses if present
Description: imperative mood, lowercase, no period, max 72 chars after prefix
```

Projects can override with custom prompts via `--prompt-file`.

## Alternative designs considered

### Option A (chosen): Standalone message generation

```bash
darna --commit-msg=claude  # Print message to stdout
```

**Pros:**

- Orthogonal to `--committable`; works on any staged changes
- Composable with shell (`git commit -m "$(darna --commit-msg)"`)
- User can preview/edit before committing
- Works in loop workflows without tying to commit action

**Cons:**

- Requires combining with `git commit` manually
- Prerequisite: files must be staged (via `git add` or any other method)

### Option B (rejected): Integrated with `--committable`

```bash
darna --committable --commit-msg=claude
```

**Pros:**

- Single command for the whole workflow

**Cons:**

- Conflates file selection and message generation
- Breaks orthogonality; `--committable` becomes more complex
- Harder to use independently (what if you want to generate a message for manually staged files?)

### Option C (rejected): Auto-commit mode

```bash
darna --auto-commit=claude  # Stage, generate message, AND commit
```

**Pros:**

- Fully automated

**Cons:**

- Too opinionated; removes user control
- Dangerous if message generation fails or produces poor results
- Harder to integrate with pre-commit hooks or review workflows

## Consequences

### Positive

- **Streamlines agent workflows**: Agents can generate commit messages without implementing their own prompt engineering.
- **Consistent style**: Projects can enforce commit message conventions via shared prompt files.
- **Works offline**: No network calls; agents run locally.
- **Extensible**: New agents can be added by implementing the `Agent` interface.
- **Composable**: Fits naturally into existing shell-based workflows.

### Negative

- **Requires agent installation**: Users must install Claude Code, Codex, etc. separately.
- **Agent-specific behavior**: Different agents may produce different message styles even with the same prompt.
- **No feedback loop**: If the generated message is poor, users must manually edit or regenerate (no interactive refinement).

### Neutral

- **Scope**: Only generates first line (summary). Commit body generation isn't implemented because:
  - Atomic commits are inherently small and focused — the diff itself is self-documenting
  - For single-purpose changes, summary + code diff often tells the complete story
  - Bodies add most value for context not in the diff (why over what), but atomic commits minimize this need
  - Summary generation is well-defined (Conventional Commits spec); body generation requires heuristics for when/how much detail
  - 80/20 rule: summary-only delivers most value with minimal complexity; bodies can be added incrementally if demand emerges
- **Validation**: Doesn't validate the generated message against project conventions (could be added as separate tool).

## Future enhancements

While not in scope for this ADR, potential extensions include:

- **Commit body generation**: Extend beyond the summary line to generate full commit messages with body paragraphs. Most valuable for: explaining "why" when it's not obvious from the diff, documenting breaking changes and migration paths, providing context for complex refactorings. Less critical for typical atomic commits where the summary + diff is self-explanatory.
- **Message validation**: Check generated messages against project conventions (character limits, forbidden words, required patterns).
- **MCP server tool**: Expose message generation via MCP server (ADR-003) for agent integration without shell.
- **Feedback loop**: Interactive mode where agents can refine messages based on user feedback.
- **Multi-file commit messages**: For commits spanning multiple logical changes, generate structured messages that explain each part.

## References

- **ADR-000**: Atomic commit validation — the foundation that makes focused message generation possible.
- **ADR-001**: Committable file selection — complements message generation in automated workflows.
- **ADR-003**: MCP server support — potential future integration point for agent message generation.
- **Conventional Commits**: https://www.conventionalcommits.org/ — the default message format.
- **GitHub Issue #1**: Original feature request for LLM commit message generation.
