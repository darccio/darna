# Proactive atomic commit file selection for autonomous agents

The current `darna` implementation validates whether staged files form an atomic commit (reactive mode). For autonomous agents and developer workflows, a complementary capability is needed: identifying which unstaged files *can* be committed atomically without requiring additional changes (proactive mode). **This ADR proposes adding a `--committable` flag that outputs file paths suitable for direct use with `git add` or `git commit`.**

This enables workflows like:
```bash
# Stage files that can be committed atomically.
git add $(darna --committable)

# Commit files directly with a message.
git commit -m "feat: add user authentication" $(darna --committable)

# Agent workflow: discover → stage → generate message → commit.
FILES=$(darna --committable)
git add $FILES
MESSAGE=$(generate-commit-message $FILES)
git commit -m "$MESSAGE"
```

The key distinction from the default mode: instead of checking if what's *already staged* is atomic, this mode discovers what *could be staged* atomically.

## Problem Statement

### Current Limitation

The existing `darna` tool operates in a reactive validation mode:
1. Developer stages files manually with `git add`
2. Developer attempts to commit with `git commit`
3. The pre-commit hook runs `darna` to validate atomicity
4. If validation fails, developer must stage additional files and retry

This workflow has several limitations for autonomous agents and interactive development:

**For autonomous agents:**
- Cannot progressively commit independent changes without human intervention
- Must analyze all changes at once rather than creating focused commits
- Lack guidance on which files form natural commit boundaries
- Cannot generate meaningful commit messages without knowing commit scope

**For developers:**
- Must guess which files to stage together
- May accidentally create non-atomic commits if they miss dependencies
- No tooling to discover natural commit boundaries in large changesets
- Requires trial-and-error: stage files → run validation → add more files → retry

### Desired Behavior

A proactive mode that:
1. Analyzes all modified files (both staged and unstaged)
2. Identifies files that can be committed atomically without additional dependencies
3. Outputs file paths in a format suitable for shell command substitution
4. Enables autonomous agents to create meaningful, focused commits
5. Helps developers discover natural commit boundaries

### Use Cases

**Use Case 1: Autonomous agent creating commits**
```bash
# Agent modifies multiple files during a task.
# Agent wants to commit changes progressively.

while [ -n "$(darna --committable)" ]; do
    FILES=$(darna --committable)
    git add $FILES
    MESSAGE=$(agent-generate-message --files $FILES --style conventional)
    git commit -m "$MESSAGE"
done
```

**Use Case 2: Developer with large changeset**
```bash
# Developer has been working for several hours.
# Multiple features/fixes are interleaved.
# Developer wants to create separate atomic commits.

# Scenario: Modified files A, B, C where A→B (A depends on B)
# B and C are independent.

# First commit: B (independent, comes before C lexicographically).
git add $(darna --committable)  # Returns: B
git commit -m "refactor: extract validation logic"

# Second commit: A (now independent since B is committed).
git add $(darna --committable)  # Returns: A
git commit -m "feat: add user authentication"

# Third commit: C (independent).
git add $(darna --committable)  # Returns: C
git commit -m "fix: update error handling"
```

**Use Case 3: Interactive staging assistance**
```bash
# Developer wants guidance on what to commit.
darna --committable --explain

# Output:
# Committable file:
#   internal/git/git.go
# Reason: Independent file (all dependencies already committed)
#
# Remaining files are NOT committable:
#   internal/validator/validator.go (depends on unstaged internal/validator/validator_test.go)
#   internal/validator/validator_test.go (depends on unstaged internal/validator/validator.go)
#   cmd/darna/main.go (depends on unstaged internal/analyzer/analyzer.go)
```

## Architectural Decisions

The following table summarizes the key design decisions for the proactive mode:

| Aspect | Decision | Rationale |
|--------|----------|-----------|
| **Flag name** | `--committable` | Clear, actionable verb; describes output (files that can be committed) |
| **Alternative flag** | `--select` | Shorter alias for interactive use |
| **Output format** | Space-separated relative paths | Compatible with `git add` and `git commit` via command substitution |
| **File selection** | All modified unstaged files | Analyzes the full set of available changes, not just what's staged |
| **Atomicity strategy** | Forward closure validation | Check if a file and all its transitive dependencies can be committed together |
| **Multiple candidates** | Return first valid set only | Simple, predictable; allows progressive commits by running multiple times |
| **Order preference** | Lexicographic by file path | Deterministic, predictable output; no heuristics needed |
| **Staged file handling** | Exclude from selection | If already staged, assume user/agent has made an explicit choice |
| **Zero matches behavior** | Output nothing, exit 0 | Allows safe use in loops (`while [ -n "$(darna --committable)" ]`) |
| **Verbose mode** | `--committable -v` shows reasoning | Helps debugging and understanding why files were/weren't selected |
| **Integration point** | Reuse existing dependency graph | No new analysis infrastructure; add selection logic to validator package |

## Comparison: Standard Mode vs. Committable Mode

The following table clarifies the critical differences between the two modes:

| Aspect | Standard Mode (ADR 000) | `--committable` Mode (This ADR) |
|--------|------------------------|--------------------------------|
| **Purpose** | Validate staged commit is atomic | Discover independent files |
| **Input** | Staged files only | All modified/untracked files |
| **Dependency rule** | CAN depend on other staged files | CANNOT depend on any changeset files |
| **Key check** | Dependencies must be staged OR committed | Dependencies must ALL be committed (not in changeset) |
| **Output** | Violations or success message | Independent file paths |
| **Exit code** | 0 = valid, 1 = violations | 0 = success (even if no files) |
| **Use case** | Prevent bad commits (reactive) | Progressive commit workflow (proactive) |
| **Returns** | Error messages with violations | Single file path at a time |
| **Multiple files** | All staged files validated together | Returns one independent file per invocation |

**Example illustrating the difference:**

```bash
# Scenario: Files A and B are both modified. A depends on B.

# Standard mode (validating a commit):
$ git add A B
$ darna
# ✓ Success: Staged files form an atomic commit
# (A depends on B, but B is also staged, so no violation)

# Committable mode (discovering what can be committed):
$ darna --committable
B
# Returns B only (B is independent)
# A is NOT returned (A depends on B, which is in the changeset)

$ git add B && git commit -m "update B"
$ darna --committable
A
# Now A is committable (B is committed, not in changeset anymore)
```

## Algorithm Design

### High-Level Approach

The proactive mode follows this algorithm:

1. **Identify candidate files** - Get all modified unstaged `.go` files from git
2. **Build dependency graph** - Load packages and analyze dependencies (reuse existing logic)
3. **Compute atomic sets** - For each candidate file, determine if it can be committed with its dependencies
4. **Filter committable sets** - Keep only sets where all files are available (modified or committed)
5. **Select best set** - Choose the first valid set (lexicographically by primary file path)
6. **Output file paths** - Print space-separated relative paths to stdout

### Detailed Algorithm

**Step 1: Get candidate files**
```
candidates = git diff --name-only (unstaged files)
candidates += git ls-files --others --exclude-standard (untracked files)
candidates = filter to *.go files
candidates = exclude staged files (let default mode validate those)
```

**Step 2: Analyze dependencies (reuse existing infrastructure)**
```
absWorkDir = filepath.Abs(workDir)
statuses = git.GetAllFileStatus()
overlay = buildOverlay() for partially-staged files
packages = analyzer.LoadPackages(absWorkDir, overlay, "./...")
dependencyGraph = graph.NewDependencyGraph()
for pkg in packages:
    dependencyGraph.AnalyzePackage(pkg)
```

**Step 3: For each candidate file, check if it's independent**
```
For file in candidates (sorted lexicographically):
    symbols = dependencyGraph.FileSyms[file]

    isIndependent = true
    for symID in symbols:
        deps = dependencyGraph.TransitiveDeps(symID)
        for depID in deps:
            depSym = dependencyGraph.Symbols[depID]
            if depSym != nil:
                depFile = depSym.File

                # Check if dependency is in the changeset.
                if depFile is modified/unstaged/untracked:
                    isIndependent = false
                    break

        if not isIndependent:
            break

    # Also check that the file itself isn't staged.
    if file is staged:
        isIndependent = false

    if isIndependent:
        return [file]  # Return single independent file.

return []  # No independent files found.
```

**Step 4: Output results**
```
if len(files) > 0:
    print(strings.Join(files, " "))
    exit(0)
else:
    # No committable files.
    exit(0)  # Exit success for safe shell scripting.
```

### Atomicity Definition

A file is **committable** if and only if:
1. The file is modified (staged/unstaged) or untracked
2. ALL its transitive dependencies are already committed (NOT in the changeset)
3. The file itself is not currently staged (avoid interfering with manual staging)

**Key insight**: Committable = INDEPENDENT. The file can be committed by itself without requiring any other files from the changeset.

A file is **not committable** if:
- It depends on ANY other file in the changeset (staged/unstaged/untracked)
- It depends on a file that doesn't exist (broken dependency)
- The file itself is already staged (let default validation mode handle staged files)

**Critical distinction from standard validation mode**:
- **Standard mode**: Staged files CAN depend on other staged files (no violation)
- **Committable mode**: Files CANNOT depend on any files in the changeset (must be independent)

### Edge Cases

**Circular dependencies**
- Files A and B have circular dependencies between them
- Neither file is independent (A depends on B, B depends on A)
- `--committable` returns nothing until both are removed or committed together manually
- This is correct behavior: circular dependencies cannot be committed progressively

**Partially staged files (MM status)**
- File has both staged changes and unstaged changes
- Exclude from committable selection (already explicitly staged)
- Let default validation mode handle staged files

**Multiple independent changes**
- Files A, B, C are all independent (no inter-dependencies)
- Algorithm returns one file at a time (lexicographically first)
- Running multiple times progressively commits each file separately
- Example: First run returns A, second run returns B, third run returns C

**New package with multiple files**
- Package has multiple new files with internal dependencies
- Files depend on each other, so none are independent
- `--committable` returns nothing (files must be committed together manually)
- Alternative: commit files one at a time after removing dependencies

**Generated files**
- Generated `.pb.go` files are treated like regular files
- If a file depends on unstaged generated files, it's NOT committable
- Consistent with default mode's treatment of generated files
- User must stage generated files manually first, then dependent files become committable

## Implementation Changes

### New Flag in cmd/darna/main.go

Add `--committable` flag to CLI:
```go
committable := flag.Bool("committable", false, "output files that can be committed atomically")
select := flag.Bool("select", false, "alias for --committable")

flag.Parse()

if *committable || *select {
    files, err := validator.FindCommittableFiles(ctx, *workDir)
    if err != nil {
        writeString(os.Stderr, "Error: "+err.Error()+"\n")
        os.Exit(1)
    }

    if len(files) > 0 {
        writeString(os.Stdout, strings.Join(files, " ")+"\n")
    }

    os.Exit(0)
}
```

### New Function in internal/validator/validator.go

Add `FindCommittableFiles` function:
```go
// FindCommittableFiles identifies files that can be committed atomically.
// Returns relative file paths suitable for use with git add/commit.
func FindCommittableFiles(ctx context.Context, workDir string) ([]string, error) {
    absWorkDir, err := filepath.Abs(workDir)
    if err != nil {
        return nil, fmt.Errorf("resolving work dir: %w", err)
    }

    // Get file statuses from git.
    statuses, err := git.GetAllFileStatus(ctx)
    if err != nil {
        return nil, fmt.Errorf("getting file status: %w", err)
    }

    // Identify candidates: modified unstaged or untracked files.
    candidates := getCandidates(absWorkDir, statuses)
    goFiles := git.FilterGoFiles(candidates)

    if len(goFiles) == 0 {
        return nil, nil  // Nothing to commit.
    }

    // Build overlay and load packages.
    overlay := buildOverlay(ctx, absWorkDir, statuses)
    pkgs, err := analyzer.LoadPackages(absWorkDir, overlay, "./...")
    if err != nil {
        return nil, fmt.Errorf("loading packages: %w", err)
    }

    // Build dependency graph.
    dg := graph.NewDependencyGraph()
    for _, pkg := range pkgs {
        dg.AnalyzePackage(pkg)
    }

    // Find first committable atomic set.
    atomicSet := findCommittableSet(dg, goFiles, statuses, absWorkDir)

    // Convert to relative paths for output.
    relPaths := make([]string, 0, len(atomicSet))
    for _, file := range atomicSet {
        relPath, err := filepath.Rel(absWorkDir, file)
        if err != nil {
            relPath = file
        }
        relPaths = append(relPaths, relPath)
    }

    sort.Strings(relPaths)  // Deterministic output order.

    return relPaths, nil
}
```

### Helper Function: getCandidates

```go
func getCandidates(absWorkDir string, statuses map[string]git.FileStatus) []string {
    var candidates []string

    for file, status := range statuses {
        absPath, err := filepath.Abs(filepath.Join(absWorkDir, file))
        if err != nil {
            continue
        }

        // Include files that are:
        // - Modified unstaged (worktree != ' ')
        // - Untracked (staging == '?')
        // Exclude files that are already staged (staging != ' ' and staging != '?').

        isStaged := status.Staging != ' ' && status.Staging != '?'
        isModifiedOrUntracked := status.Worktree != ' ' || status.Staging == '?'

        if !isStaged && isModifiedOrUntracked {
            candidates = append(candidates, absPath)
        }
    }

    return candidates
}
```

### Helper Function: findCommittableFile

```go
func findCommittableFile(
    dg *graph.DependencyGraph,
    candidates []string,
    statuses map[string]git.FileStatus,
    absWorkDir string,
) []string {
    // Sort candidates for deterministic order.
    sort.Strings(candidates)

    // Track which files are in the changeset (modified/unstaged/untracked).
    changesetFiles := make(map[string]bool)
    for file := range statuses {
        absPath := filepath.Join(absWorkDir, file)
        changesetFiles[absPath] = true
    }

    // For each candidate, check if it's independent.
    for _, file := range candidates {
        if isIndependent(dg, file, changesetFiles, statuses, absWorkDir) {
            // Convert to relative path.
            relPath, err := filepath.Rel(absWorkDir, file)
            if err != nil {
                relPath = file
            }
            return []string{relPath}  // Return single independent file.
        }
    }

    return nil  // No independent files found.
}

func isIndependent(
    dg *graph.DependencyGraph,
    file string,
    changesetFiles map[string]bool,
    statuses map[string]git.FileStatus,
    absWorkDir string,
) bool {
    // Check if file itself is staged (if so, skip it).
    relPath, err := filepath.Rel(absWorkDir, file)
    if err != nil {
        return false
    }

    if status, exists := statuses[relPath]; exists {
        if status.Staging != ' ' && status.Staging != '?' {
            return false  // File is staged, let default mode handle it.
        }
    }

    // Get all symbols defined in this file.
    symbols := dg.FileSyms[file]

    // Check if any dependency is in the changeset.
    for _, symID := range symbols {
        deps := dg.TransitiveDeps(symID)

        for _, depID := range deps {
            depSym := dg.Symbols[depID]
            if depSym == nil {
                continue
            }

            depFile := depSym.File

            // If dependency is in the changeset, file is NOT independent.
            if changesetFiles[depFile] {
                return false
            }
        }
    }

    return true  // File is independent (all dependencies are committed).
}
```

## Output Format

### Default Output (Success)

**When a committable file is found:**
```bash
$ darna --committable
internal/git/git.go
```

Note: Only ONE file is returned per invocation (the first independent file in lexicographic order).

**When no committable files exist:**
```bash
$ darna --committable
$ echo $?
0
```

The empty output with exit code 0 allows safe use in loops:
```bash
while [ -n "$(darna --committable)" ]; do
    git add $(darna --committable)
    git commit -m "automatic commit"
done
```

### Verbose Output (with -v flag)

```bash
$ darna --committable -v
Analyzing 15 modified files...

Committable file found:
  internal/git/git.go

Reason: Independent file (all dependencies already committed).

Remaining files are NOT committable:
  cmd/darna/main.go
    Depends on: internal/analyzer/analyzer.go (modified, in changeset)
    Status: Not independent

  internal/validator/validator.go
    Depends on: internal/validator/validator_test.go (modified, in changeset)
    Status: Not independent

  internal/validator/validator_test.go
    Depends on: internal/validator/validator.go (modified, in changeset)
    Status: Not independent
```

### Error Output

**Package loading error:**
```bash
$ darna --committable
Error: loading packages: package example.com/project/internal/broken: ...
$ echo $?
1
```

**Git error:**
```bash
$ darna --committable
Error: getting file status: exit status 128: fatal: not a git repository
$ echo $?
1
```

## Integration with Default Mode

The two modes are complementary:

| Aspect | Default Mode | `--committable` Mode |
|--------|--------------|----------------------|
| **Trigger** | Pre-commit hook (automatic) | Manual invocation or agent script |
| **Input** | Staged files | All modified/untracked files |
| **Dependency rule** | Staged files CAN depend on other staged files | Files CANNOT depend on any changeset files |
| **Analysis** | Validates existing staging is atomic | Discovers independent files |
| **Output** | Violations (stderr) | Single file path (stdout) |
| **Exit code** | 0 = valid, 1 = violations | 0 = success (even if no files), 1 = error |
| **Use case** | Prevent non-atomic commits | Enable progressive commits |
| **Returns** | All violations found | One file at a time |

### Workflow Example

**Traditional workflow with default mode only:**
```bash
# Developer manually stages files.
git add internal/validator/validator.go

# Pre-commit hook runs automatically.
git commit -m "refactor validator"
# Output: Commit is not atomic. Missing files need to be staged:
#   internal/validator/validator_test.go

# Developer adds missing file.
git add internal/validator/validator_test.go
git commit -m "refactor validator"
# Success!
```

**Enhanced workflow with --committable mode:**
```bash
# Scenario: validator.go and validator_test.go are both modified.
# validator_test.go depends on validator.go.

# Discover independent file (validator.go is independent).
git add $(darna --committable)  # Adds validator.go only

# Pre-commit hook validates (should always pass for independent files).
git commit -m "refactor validator"
# Success!

# Now validator_test.go is independent (validator.go is committed).
git add $(darna --committable)  # Adds validator_test.go
git commit -m "add validator tests"
# Success!
```

## Performance Considerations

### Similarity to Default Mode

The `--committable` mode performs nearly identical analysis to the default mode:
1. Load all packages with `packages.Load()`
2. Build complete dependency graph
3. Analyze dependencies for each file

The primary difference is the validation logic:
- **Default mode**: Check if staged files → all dependencies are staged/committed
- **Committable mode**: For each unstaged file → check if it + dependencies can be committed

### Performance Characteristics

**Time complexity**: O(F × D) where F = number of candidate files, D = average transitive dependencies
- Same graph building cost as default mode (O(P) for P packages)
- Additional per-file analysis: O(F × D) where F is typically small (10-50 files)
- Early exit on first committable set reduces average case

**Memory**: Same as default mode (full dependency graph in memory)

**Typical runtime**: <2 seconds for repositories with <100 packages (same as default mode)

### Future Optimizations

The performance optimizations outlined in ADR 000 apply equally to `--committable` mode:
1. **Selective package loading** - Load only packages containing modified files
2. **Dependency graph caching** - Reuse cached graph across invocations
3. **Parallel analysis** - Analyze candidate files in parallel

These optimizations benefit both modes simultaneously.

## Testing Strategy

### Unit Tests

Add to `internal/validator/validator_test.go`:
```go
func TestFindCommittableFiles(t *testing.T) {
    tests := []struct {
        name           string
        modifiedFiles  []string
        dependencies   map[string][]string  // file -> []dependency files
        want           []string
    }{
        {
            name: "independent files",
            modifiedFiles: []string{"a.go", "b.go"},
            dependencies: map[string][]string{
                "a.go": {},
                "b.go": {},
            },
            want: []string{"a.go"},  // Returns first one.
        },
        {
            name: "file with dependency",
            modifiedFiles: []string{"main.go", "utils.go"},
            dependencies: map[string][]string{
                "main.go": {"utils.go"},
                "utils.go": {},
            },
            want: []string{"utils.go"},  // Independent file first.
        },
        {
            name: "circular dependency",
            modifiedFiles: []string{"a.go", "b.go"},
            dependencies: map[string][]string{
                "a.go": {"b.go"},
                "b.go": {"a.go"},
            },
            want: nil,  // Neither is independent (both depend on each other in changeset).
        },
        {
            name: "dependency not modified",
            modifiedFiles: []string{"main.go"},
            dependencies: map[string][]string{
                "main.go": {"lib.go"},  // lib.go not modified.
            },
            want: nil,  // Cannot commit main.go alone.
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation.
        })
    }
}
```

### E2E Tests

Add to `internal/validator/validator_e2e_test.go`:
```go
func TestCommittableFiles_E2E(t *testing.T) {
    repo := setupTestRepo(t)

    // Modify multiple independent files.
    modifyFile(t, repo, "alpha.go", "// change 1\n")
    modifyFile(t, repo, "beta.go", "// change 2\n")

    // Find committable files.
    files, err := validator.FindCommittableFiles(context.Background(), repo)
    require.NoError(t, err)

    // Should return first file (lexicographically).
    assert.Equal(t, []string{"alpha.go"}, files)

    // Commit first file.
    runGit(t, repo, "add", "alpha.go")
    runGit(t, repo, "commit", "-m", "update alpha")

    // Find next committable file.
    files, err = validator.FindCommittableFiles(context.Background(), repo)
    require.NoError(t, err)

    // Should return second file.
    assert.Equal(t, []string{"beta.go"}, files)
}

func TestCommittableFiles_Dependencies_E2E(t *testing.T) {
    repo := setupTestRepo(t)

    // Modify file and its dependency.
    // main.go depends on service.go.
    modifyFile(t, repo, "main.go", "// uses service\n")
    modifyFile(t, repo, "service.go", "// change service\n")

    // Find committable files.
    files, err := validator.FindCommittableFiles(context.Background(), repo)
    require.NoError(t, err)

    // Should return only service.go (it's independent).
    // main.go is NOT returned because it depends on service.go (which is in changeset).
    assert.Equal(t, []string{"service.go"}, files)

    // Commit service.go.
    runGit(t, repo, "add", "service.go")
    runGit(t, repo, "commit", "-m", "update service")

    // Now main.go should be committable.
    files, err = validator.FindCommittableFiles(context.Background(), repo)
    require.NoError(t, err)

    assert.Equal(t, []string{"main.go"}, files)
}
```

### Integration Tests (Shell Scripts)

Add `test/test-committable.sh`:
```bash
#!/bin/bash
set -e

# Create test repository.
git init test-repo
cd test-repo

# Create independent files.
echo "package main" > a.go
echo "package main" > b.go
git add . && git commit -m "initial"

# Modify both files.
echo "// change 1" >> a.go
echo "// change 2" >> b.go

# Both files are independent, so first one lexicographically is returned.
OUTPUT=$(darna --committable)
if [ "$OUTPUT" != "a.go" ]; then
    echo "Expected 'a.go', got '$OUTPUT'"
    exit 1
fi

# Commit first file.
git add $(darna --committable)
git commit -m "update a"

# Now second file should be returned (a is committed, b is independent).
OUTPUT=$(darna --committable)
if [ "$OUTPUT" != "b.go" ]; then
    echo "Expected 'b.go', got '$OUTPUT'"
    exit 1
fi

# Commit second file.
git add $(darna --committable)
git commit -m "update b"

# No more committable files.
OUTPUT=$(darna --committable)
if [ -n "$OUTPUT" ]; then
    echo "Expected empty output, got '$OUTPUT'"
    exit 1
fi

echo "All tests passed!"
```

## Alternatives Considered

### Alternative 1: Return All Committable Sets

**Approach**: Return multiple independent atomic sets, not just the first one.

**Output format:**
```bash
$ darna --committable
# Set 1
internal/validator/validator.go internal/validator/validator_test.go
# Set 2
internal/git/git.go
# Set 3
cmd/darna/main.go internal/analyzer/analyzer.go
```

**Pros:**
- Gives developer/agent more choices
- Shows complete picture of committable changes

**Cons:**
- Complex output format (requires parsing)
- Cannot use directly with `git add`
- Ambiguous which set to commit first
- Requires additional tooling to select a set

**Decision**: Rejected. Simplicity and shell compatibility are more important. Users can run the command multiple times to progressively commit sets.

### Alternative 2: Interactive Selection

**Approach**: Use an interactive TUI (like `git add -p`) to let the user select which set to commit.

**Pros:**
- User-friendly for manual workflows
- Can show reasoning for each set
- Allows customization (add/remove files from set)

**Cons:**
- Not useful for autonomous agents (requires human interaction)
- Adds significant complexity (TUI library dependency)
- Cannot be used in scripts or CI environments
- Out of scope for a simple CLI tool

**Decision**: Rejected. Conflicts with the primary use case (autonomous agents). Could be added as a separate `--interactive` flag in the future.

### Alternative 3: JSON Output Format

**Approach**: Output structured JSON for programmatic consumption.

**Output format:**
```json
{
  "committable": true,
  "files": ["internal/validator/validator.go", "internal/validator/validator_test.go"],
  "reason": "self-contained change",
  "dependencies": {
    "internal/validator/validator.go": ["internal/git/git.go"],
    "internal/validator/validator_test.go": []
  }
}
```

**Pros:**
- Easy to parse in scripts
- Can include rich metadata
- Extensible format

**Cons:**
- Requires JSON parsing in shell scripts (`jq`)
- More verbose for simple use case
- Overhead for basic workflows

**Decision**: Rejected for default output. Space-separated paths are simpler and directly compatible with `git add`. JSON output could be added via `--format json` flag if needed in the future.

### Alternative 4: Stage Files Automatically

**Approach**: Instead of outputting file paths, automatically stage the committable files.

**Usage:**
```bash
$ darna --stage
Staged files:
  internal/validator/validator.go
  internal/validator/validator_test.go
```

**Pros:**
- One less step (no need for `git add`)
- Simpler user experience

**Cons:**
- Side effects are surprising (tool modifies git state)
- Violates principle of least surprise
- Harder to preview before staging
- Doesn't work with `git commit` directly

**Decision**: Rejected. The tool should output information, not modify state. The user/agent should explicitly stage files with `git add`.

## Future Enhancements

### 1. Explain Mode (--committable --explain)

Show detailed reasoning for committable/non-committable files:
```bash
$ darna --committable --explain
Committable set:
  internal/validator/validator.go
  internal/validator/validator_test.go

Reason: Self-contained changes to validator package.

Dependencies:
  validator.go → internal/git/git.go (already committed ✓)
  validator.go → internal/graph/graph.go (already committed ✓)
  validator_test.go → validator.go (included in set ✓)

Remaining files cannot be committed:
  cmd/darna/main.go
    → Depends on internal/analyzer/analyzer.go (not modified ✗)

  internal/git/git.go
    → Depends on internal/types/status.go (not modified ✗)
```

### 2. Multiple Sets Mode (--committable --all)

Return all committable sets, not just the first:
```bash
$ darna --committable --all --format json
[
  {
    "files": ["internal/validator/validator.go", "internal/validator/validator_test.go"],
    "reason": "self-contained change"
  },
  {
    "files": ["internal/git/git.go"],
    "reason": "independent change"
  }
]
```

### 3. Scoring and Priority

Rank committable sets by some heuristic (size, complexity, independence):
```bash
$ darna --committable --prioritize smallest
internal/git/git.go

$ darna --committable --prioritize largest
internal/validator/validator.go internal/validator/validator_test.go internal/graph/graph.go
```

### 4. Commit Message Generation

Integrate with commit message generation tools:
```bash
$ darna --committable --message
internal/validator/validator.go internal/validator/validator_test.go

Suggested message:
  refactor(validator): extract file categorization logic

  - Extract categorizeFiles function for reusability
  - Add unit tests for edge cases
  - Improve readability of validation logic
```

### 5. Watch Mode

Continuously monitor for committable files:
```bash
$ darna --committable --watch
Watching for committable files...

[12:34:56] Committable: internal/validator/validator.go
[12:35:23] Committable: internal/git/git.go internal/git/git_test.go
```

## Migration and Rollout

### Backwards Compatibility

The new `--committable` flag is purely additive:
- No changes to default behavior (pre-commit hook validation)
- No changes to existing flags or output format
- No breaking changes to API or data structures

Existing users can upgrade without any workflow changes.

### Adoption Path

**Phase 1: Manual experimentation**
- Developers try `--committable` manually
- Validate correctness and usefulness
- Gather feedback on edge cases

**Phase 2: Agent integration**
- Autonomous agents adopt `--committable` for progressive commits
- Monitor for false positives/negatives
- Tune algorithm based on real-world usage

**Phase 3: Workflow integration**
- Add to development guides and documentation
- Create shell aliases and helper scripts
- Integrate with commit message generation tools

### Documentation Updates

Update the following:
1. **README.md** - Add usage examples for `--committable`
2. **man page / --help** - Document the new flag
3. **Architecture documentation** - Reference this ADR
4. **Agent integration guide** - Provide examples for AI agents

## Summary

The `--committable` flag transforms `darna` from a reactive validation tool into a proactive commit assistant. By identifying **independent** files that can be committed without requiring any other files in the changeset, it enables:

**For autonomous agents:**
- Progressive, focused commits without human intervention
- One file at a time, building up the repository incrementally
- Safe, atomic commits guaranteed by design (each file is independent)
- Foundation for high-quality commit message generation (focused, single-file commits)

**For developers:**
- Guidance on which files can be safely committed first
- Reduced trial-and-error in staging files
- Confidence that commits will pass validation
- Faster workflow (discover → stage → commit → repeat)

**Key design principles:**
- **Independence**: Returns files that DON'T depend on other changeset files (opposite of standard mode)
- **Simplicity**: Single file output works directly with `git add`
- **Predictability**: Deterministic ordering (lexicographic) ensures consistent behavior
- **Progressive workflow**: Run multiple times to commit files one by one
- **Composability**: Integrates seamlessly with existing git workflows
- **Safety**: Exit code 0 on empty output allows safe use in loops
- **Reusability**: Leverages existing dependency graph infrastructure

**Critical distinction from standard mode:**
- **Standard mode**: Validates that staged files + their dependencies are ALL staged (allows inter-dependencies)
- **Committable mode**: Finds files with NO dependencies in the changeset (returns independent files only)

The implementation requires approximately 150-200 lines of new code (excluding tests) and reuses 90% of the existing validation infrastructure. This makes it a high-value, low-risk addition to the tool.
